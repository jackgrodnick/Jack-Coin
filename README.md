# Jack-Coin
### Here's a link to my GitHub with the code since I will be describing each line of code and what it does. https://github.com/jackgrodnick/Jack-Coin/blob/main/jackCoin.sol. The first line of code initializes the version of solidity I will be using. I updated the previous code I had to work on the newest version of solidity. So the first line says to compile the code to any version of solidity at or above 8.6 that compiles without any errors. Solidity is just the language I coded the token in, which is Ethereum's native language. Ethereum is just a decentralized network that allows anyone to run smart contracts and decentralized applications on it. I believe solidity is built on Javascript since its syntax is very similar, but it also has features from other languages like C and Java. I don't have much experience with C and Java, but the features I see from C is how you initialize variables and stuff. Features I see from Java are kind of how it's structured. Everything in solidity must be written in a contract, like how everything in Java has to be written in a class. It also has similar public and private or internal classifiers for functions and variables. Everything in the solidity contract can be deployed on the Ethereum network, which gets sent across all the nodes in the system, making it completely immutable by anyone except if the developer wishes to put that into the code. Or the developer can put that they are the only ones allowed to change it. This is only possible to a certain extent, but I'm not a solidity expert. This immutable code is called code is law since you can interact with it and build on top of it, but you can't change the underlying code. I'm not deploying this contract because of the cost, so I didn't write any code that would allow me to edit it after being deployed. It costs ETH or Ethereum's currency to deploy contracts since people facilitating the network must be compensated to continue running the network. After watching MIT's course on crypto coins and tokens, I've become very bearish on the future of them. I like the idea of stable coins to an extent, and I do see a possibility of non stable coins existing if people want them, but I don't think that's very likely. It's totally up to the people, so I might be wrong. I see a very bright future for decentralization and blockchain to a certain extent, but I don't believe coins and tokens will be the fruit of the technology. This technology is actually way more centralized than people realize and less secure for foreign nations to break them people think. For instance, North Korea could destroy bitcoins value with a 51% attack with like 10 billion in computers, but I don't believe there's much incentive to do this yet. Also, there are many downsides to bitcoin, like possible threats from mining pools and the fact it has no intrinsic value, so it will most likely always be volatile. Some people think the dollar doesn't have intrinsic value, which I actually don't think it does, but it might, I don't know. The dollar is backed by the government, though, which gives it some value. For example, you can't pay taxes in bitcoin, and you will go to jail if you don't pay your taxes in dollars, so people have to find a way to pay their taxes with a limited currency which means people have to compete to get a dollar. This gives it value in my mind. People also say bitcoin is a better gold which, in theory, it is, but I don't believe we should have another gold which is a pretty stupid asset in my mind and many other profession's minds. Gold also has a longer proven track record than bitcoin as well. I don't think bitcoin will be around in 3 thousand years. Infinite varieties of gold also can't be created like in the crypto world. Also, the government allows you to buy stuff with dollars which also gives it value to an extent, I'm pretty sure. Also, lots of risks from quantum computers in the future since superposition allows for new algorithms that have the potential to devastate the security of these coins and tokens. Also, just innovation, in general, is a risk. I don't believe this is like dollars moving from physical to digital in any way because the digital dollar is still a dollar and can be moved to newer technology in the future. Bitcoin can't be converted to newer technology, in my opinion, because of the nature of blockchain, but it can be updated to a certain extent by developers, which is also a risk from centralization that people don't realize. This means if there is a flaw in the technology or if something newer comes around, bitcoins value could be affected significantly because who's going to buy your bitcoin if this happens. This doesn't happen with the dollar, as I just went over. Also, this is very unlikely, and I'm not a cryptographic hashing function expert, but SHA256 isn't proven just to be one way and could still theoretically be reversed, but a lot of the internet is reliant on this and hasn't been broken so far and is probably too complicated or something for the time being to be broken, but this is also another potential risk for cryptos. Since public addresses are generated from private keys using SHA256 like in this photo https://cdn-images-1.medium.com/max/1200/1*3J9-LNjD-Iayqm59CNeRVA.jpeg, any flaw in SHA256 could destroy the value of cryptos. I believe there are potential uses for all types of blockchains, but I'm probably leaning more toward permission systems currently because of the risk from the centralization of decentralized networks like Ethereum and other permissionless systems from the developers. Just look at why Ethereum classic was made. Anyways as someone interested in business ventures, I'm still very interested in the world of blockchain and decentralization. I see many possibilities for the technology to lower costs in society, from legal to insurance. Also, I'm not an expert. I've just been researching a little bit over the past month, so don't trust anything I just said or take it with a grain of salt. I just wanted to write what I was thinking. Now let's continue with the code. So after the first line, I initialized the contract to Jack Token, and I already went over why this is. jackToken is initialized like this because of a common coding convention called camel case. I also changed the name to Jack Token because tokens are built on top of an application where coins are built on their very own blockchain, and I didn't do this cause I don't know how and it takes lots of time. The third line of code is a mapping function that takes an Ethereum address and assigns it a value or Jack Tokens. It's a key-value pair, and it's pretty much the same as most objects, especially Javascript ones. This mapping function is assigned to the balance variable. Next line, I initialize a variable that will hold the miner's address or the creator of the contract's address. Next, I have two events that allow others on the network to react to stuff happening on the contract. The first event sends out any transfers people are making with Jack Token, and the second event sends out who the reward was sent to every 2.5 minutes, which incentivizes people to interact with the smart contract. I believe I used 2.5 minutes because Litecoin uses it, and I wanted it to be kind of fast. Next, I initialized a bunch of public variables, including the name of the coin, symbol, max supply, circulating supply, reward, decimals. Decimals are supposed to be how much a Jack token can be divided, but I haven't figured out floats in solidity yet, so this is not implemented yet. Time of last having and time of last increase takes a timestamp set to when the reward was last halved and a timestamp of when the supply last increased. The last variable is internal, which means people can't access this variable when deployed and is used to clean up the code a little since this variable is just used to reward the creator and only used once for that purpose. The next section of code is the constructor and is only called once during the smart contract deployment. This constructor initializes the timestamps for the time of last halving and time of last increase variables. Next, it initializes the minter address by accessing the msg object and getting the sender property which holds the address of who deployed the contract. Next, the give creator reward function is called, which is defined on line 49 and gives the creator 10 percent of the max supply. This is only allowed to happen once. Next creator reward is set to 1, making it impossible for the creator to call the give creator reward function again. Next, I have the update supply function, which will halve the reward given out every four years. It also every 2.5 minutes will give the address who called it first in a valid time a reward of 10 jack tokens which is halved every four years. This incentivizes people to interact with the contract, and it costs ETH to call this function, which might give some value to the coin and allows people to obtain Jack Tokens, which is kind of like how a block is mined. This doesn't work the same way as mining a block, I believe, however, but I think the Ethereum network does that for me during transactions. Also, I don't personally believe any of this is of real value currently, but this is mostly a learning opportunity for me. The last function I have is on line 56 and just takes two parameters to make transactions of jack tokens possible. This is all pretty brief, so reach out to me if anyone reads this and has questions. Here's a video demonstration of it working on a test network here https://drive.google.com/file/d/1_n8IPbH7HBchajc8RwuCsHC8h_E9BOiT/view?usp=sharing if interested.
